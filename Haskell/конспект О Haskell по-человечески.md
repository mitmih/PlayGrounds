```shell
# компиляция со всеми предупреждениями и ошибками
stack clean && stack build --ghc-options="-Wall -Werror" && stack run
```

# Приготовимся

Haskell — кроссплатформенный язык, работающий и в Linux, и в macOS OS X, и даже в Windows.


## Устанавливаем

[stack](https://docs.haskellstack.org/en/stable/install_and_upgrade/)

`stack` умеет
+ разворачивать инфраструктуру языка
+ собирать проекты
+ устанавливать библиотеки

глобальная инфраструктура последней стабильной версии в `~/.stack`.
    
    stack setup

новый проект с именем `real`.
    
    stack new real
    cd real
    ~/real$ tree
    .
    ├── ChangeLog.md
    ├── LICENSE
    ├── README.md
    ├── Setup.hs
    ├── app
    │   └── Main.hs         <- главный модуль программы
    ├── package.yaml
    ├── real.cabal          <- сборочный конфиг проекта
    ├── src
    │   └── Lib.hs          <- ещё один модуль
    ├── stack.yaml          <- конфиг stack
    ├── stack.yaml.lock
    └── test
        └── Spec.hs         <- тесты (пока не нужны)
    3 directories, 11 files

сборка

    stack clean && stack build --ghc-options="-Wall -Werror"

скомпилированный файл `real-exe` появится внутри `.stack-work/...`

    ~/real$ stack run
    someFunc


## Модули: знакомство

Проект состоит из модулей, файлов `*.hs` с исходным кодом. Один файл = один модуль. 

`src/Lib.hs`
```Haskell
module Lib      -- имя модуля
    ( someFunc  -- интерфейс модуля
    ) where

-- содержимое модуля - одна функция
someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

`app/Main.hs` - **главный модуль приложения, т.к. здесь определена функция** `main`.
```Haskell
module Main where

import Lib          -- подключаем модуль

main :: IO ()
main = someFunc     -- используем его содержимое
```

Модули либо наши, самописные, либо чужие в библиотеках. Существует стандартная библиотека.


## Для любопытных

+ Хотя `stack` появился в 2015, он является предпочтительным стартом в мир Haskell, даже в [Haskell Platform](https://www.haskell.org/platform/) он уже есть по умолчанию.

+ Имена файлов с исходным кодом принято начинать с большой буквы - для гармонии с именем модуля:
    ```shell
    app/Main.hs # module Main ...
    src/Lib.hs  # module Lib ...
    ```

+ новый проект может ~~быть проще по структуре, если использовать шаблон `stack new real_simple simple`~~ иметь другую структуру, подробнее о шаблонах `stack templates`.


# Киты и Черепаха

Основа всего (черепаха) = `ВЫРАЖЕНИЕ`, "три кита":
+ функция
+ тип
+ класс типов


## Черепаха

Haskell-программа является набором выражений.

> Выражение (англ. expression) — это то, что может дать нам некий полезный результат в результате вычисления (англ. evaluation) этого выражения.
> 
> Некоторые выражения уменьшаются (редуцируются - англ. reduce) в результате вычислений, а другие - нет.

```Haskell
1 + 2  -- при вычислении редуцируется в 3
```

Т.е. выражения вычисляются до тех пор, пока не останется окончательное, корневое выражение. Запуск Haskell-программы = запуск всей цепочки вычислений, где корень - `main` - главная точка программы.


## Первый кит = ФУНКЦИЯ

Функция делает выражение вычислимым, *отображает* входные данные на выходные. Это как машина: закинули на вход аргумент(ы), на выходе получили значение.

```Haskell
square v = v * v  -- определяем функцию

--Функция square определяет простую зависимость: числу 2 соответствует число 4, числу 3 — 9, и так далее. Схематично это можно записать так:

-- 2 -> 4
-- 3 -> 9
-- 4 -> 16
-- 5 -> 25
-- ...

square 2 -- применяем (англ. apply) функцию к аргументу
```

Вычисление выражения `1 + 2` это тоже применение функции
```Haskell
(+) 1 2  -- применение функции (+) к двум аргументам, 1 и 2
```

> Вызов функции (т.е. подпрограммы) происходит в C-подобных языках - каждая подпрограмма доступна по некоторому адресу в памяти - но не в Haskell!
>
> **Функция в Haskell это функция в математическом смысле**, её применяют к чему-то.


## Второй кит = ТИП

Аргументы (выражения) это данные (англ. data). Данные обязательно обладают
+ типом
+ значением (содержимым)

Работа с типами характеризуется важными чертами:

+ статическая проверка
    Проверка всех типов на этапе компиляции. Если функция работает с целыми, её не получится применить к строкам. Это гарантирует отсутствие целого пласта ошибок, не получится вычесть "метры" из "рублей".

+ сила
    пример проблемы слабой типизации в C:
    ```C
    double coeff(double base) {  // возвращает значение типа double
        return base * 4.9856;
    }

    int main() {
        int value = coeff(122.04);  // неявное приведение типов мы получим не 608.4426, а 608
        ...
    }
    ```
    Благодаря сильной типизации в Haskell это невозможно, код не пройдёт компиляцию, т.к. фактический тип выражения должен соответствовать ожидаемому

+ выведение
    ```Haskell
    value = 122.04 -- компилятор автоматически выведет тип double
    
    -- простейшие cтандартные типы
    1       Int
    1.0     Double
    'a'     Char
    "hello" String
    True    Bool
    False   Bool
    ```

## Третий Кит

позже))


## Для любопытных

В Haskell между "тип" и "класс типа" есть чёткое различие, не нужно пытаться строить аналогии с другими языками, чтобы не запутаться.


# Неизменность и чистота

Узнаем, что такое «чисто функциональный» язык и почему в нём нет места оператору присваивания.

## Объявление и Определение функции в коде

Нельзя работать с функцией, которая ничего не вычисляет, но можно с функцией, которая ничего не принимает.

```Haskell
-- ОБЪЯВЛЕНИЕ функции сообщает типы принимаемых аргументов и тип вычисляемого выражения
prod    :: Int      -> Int      -> Int {- Объявление функции
имя        тип         тип         тип
функции    первого     второго     вычисленного
           аргумента   аргумента   значения
-}

-- ОПРЕДЕЛЕНИЕ функции
prod     x          y         =    x * y {- Определение функции
имя      имя        имя       это  выражение
функции  первого    второго
         аргумента  аргумента

голова функции                равно    телу функции
-}
```

Голова равна телу - ~~операция присвоения~~ **декларация равенства левой и правой частей!**

"Отныне выражение `prod x y` равно выражению `x * y`". Можно безопасно заменить выражение `prod 2 3` на `2 * 3`, а `prod 20 30` на `20 * 30` и работа программы гарантированно не изменится. Потому, что


## Чисто функциональный

Haskell чисто функциональный язык (англ. purely functional), т.к. в центре - "чистая функция" (англ. pure function). Такая функция предельно честна с нами - её выходное значение целиком определяется только входными данными. Это функция в математическом смысле.

Функция `prod 20 30` чистая, без побочных эффектов (англ. side effects), она не способна сделать ничего, кроме как вычислить `600` 


## «Присваивание? Не, не слышал…»

Императивное программирование (англ. imperative programming) - несколько парадигм, в т.ч. ООП-парадигма, когде программа является набором инструкций, которые изменяют состояние программы, поэтому там есть переменные (англ. variable) которым "присваиваются" значения.

Декларативное программирование (англ. declarative programming) использует в т.ч. функциональную парадигму, когда программа является набором выражений, которые вычисляются применением функций к аргументам (другим выражениям) и не нужны переменные с операцией присваивания. Данные, созданные в программе единожды, уже не меняются.

**Знак `=` это равенство в математическом смысле**


## Для любопытных
В процессе работы Haskell-программы новые данные вычисляются на основе уже вычисленных, из-за этой особенности в памяти образуется множество уже не нужных данных. За своевременную уборку отвечает "сборщик мусора" (англ. garbage collector, GC), который встраивается в программу компилятором `GHC`.


# Выбираем и возвращаемся

## Выглянем во внешний мир

```Haskell
{-
    многострочный комментарий
-}

main :: IO ()
main = -- однострочный комментарий
  putStrLn "Hello, world!"  -- вывод строки в консоль

```


## Выбор и выход

```Haskell
-- базовый вариант if CONDITION then EXPR1 else EXPR2
checkLocalHost :: String -> String
checkLocalHost ip =
  if ip == "127.0.0.1" || ip == "0.0.0.0"
    then "+ It`s localhost"
    else "- No, it`s not a localhost"

main :: IO ()
main =
  putStrLn
    ( checkLocalHost "8.8.8.8"
    )

-- можно переписать так:
main :: IO ()
main =
  putStrLn
    ( if "8.8.8.8" == "127.0.0.1" || "8.8.8.8"  == "0.0.0.0"
        then "It`s localhost"
        else "No, it`s not a localhost"
    )
{-
Т.е.
"..." == "127.0.0.1" || "..."  == "0.0.0.0" редуцируется до True или False

затем
if True (или False)
  then "It's a localhost!"
  else "No, it's not a localhost."
редуцируется до "It`s localhost" или "No, it`s not a localhost"
-}
```
Каким бы сложным не было ветвление, в конечном итоге выражение будет вычислено, поэтому:
+ нельзя ограничится if-then, всегда должен быть else
+ из функции нельзя выйти в произвольном месте


# Выбор и образцы

## Не только из двух
```Haskell
{-# LANGUAGE MultiWayIf #-}
-- указание расширения языка Haskell, прагмой LANGUAGE включили множественный if

module Main where

analyzeGold :: Int -> String
analyzeGold standart =
  if
      | standart == 999 -> "wow! 999 is excelent!"
      | standart == 750 -> "great! 750 is good too!"
      | standart == 585 -> "not bad! 585"
      | otherwise -> "don`t know this standart"

main :: IO ()
main = putStrLn (analyzeGold 999)
```

## Без Если и прагмы

```Haskell
module Main where

analyzeGold :: Int -> String
analyzeGold standart
    | standart == 999 = "wow! 999 is excelent!"
    | standart == 750 = "great! 750 is good too!"
    | standart == 585 = "not bad! 585"
    | otherwise = "don`t know this standart"

-- можно развернуть в одну строку
-- function arg  |    COND1     =      EXPR1     |    ...
-- функция равна или тому или тому или ...

main :: IO ()
main = putStrLn (analyzeGold 751)
```

## Сравнение с образцом

```Haskell
module Main where

ag :: Int -> String
-- Сравнение с образцом
ag 999 = "wow! 999 is excelent!"
ag 750 = "great! 750 is good too!"
ag 585 = "not bad! 585"
ag _ = "don`t know this standart"
-- '_' означает универсальный образец, сравнение с ним всегда True
-- Сравнение с образцом всегда происходит сверху вниз
-- поэтому '_' должен стоять последним

main :: IO ()
main = putStrLn (ag 585)
```

## case

```Haskell
module Main where

ag :: Int -> String
ag x =
  case x of
    999 -> "wow! 999 is excelent!"
    750 -> "great! 750 is good too!"
    585 -> "not bad! 585"
    _ -> "don`t know this standart"

main :: IO ()
main = putStrLn (ag 987)
```


# Пусть будет там, Где…

## Пусть / let

```Haskell
{-# LANGUAGE MultiWayIf #-}

module Main where

calcTime :: Int -> Int
calcTime timeIn =
  if
      | timeIn < 40 -> timeIn + 120
      | timeIn >= 40 -> timeIn + 8 + 120
      | otherwise -> 0 -- Guards do not cover entire pattern space
      {-
          классический пример магических чисел, которых нужно избегать в коде и вводить временные выражения
      -}

main :: IO ()
main = putStrLn "ok"
```

Исправляем магические числа на выражения через **let-in**
```Haskell
{-# LANGUAGE MultiWayIf #-}

module Main where

calcTime :: Int -> Int
calcTime timeIn =
  let threshold = 40
      correction = 120
      delta = 8
   in if
          | timeIn < threshold -> timeIn + correction
          | otherwise -> timeIn + delta + correction

{-
    Конструкция let-in вводит поясняющие выражения по схеме:
    let DECLARATIONS in EXPRESSION

    Эта конструкция легко читается:
    let    threshold  =      40       ... in ...

    пусть  это        будет  этому        в  том
        выражение  равно  выражению       выражении

    При желании let-выражения можно записывать и в строчку:
    let threshold = 40; correction = 120
    
    введённое конструкцией let-in выражение существует
    лишь в рамках выражения, следующего за словом in
-}

main :: IO ()
main = putStrLn "ok"
```

## Где / where
```Haskell
{-# LANGUAGE MultiWayIf #-}

module Main where

calcTime :: Int -> Int
calcTime timeIn =
  if
      | timeIn < threshold -> timeIn + correction
      | otherwise -> timeIn + delta + correction
  where
    threshold = 40
    correction = 120
    delta = 8

main :: IO ()
main = putStrLn "ok"

--{-
Ключевое слово where делает примерно то же, что и let, но промежуточные выражения задаются в конце функции. Такая конструкция читается подобно научной формуле:
  S = V * t,      -- Выражение
где
  -- Всё то, что
  -- используется
  -- в выражении.
  S = расстояние,
  V = скорость,
  t = время.

В отличие от let, которое может быть использовано для введения супер-локального выражения (как в последнем примере с delta), все where-выражения доступны в любой части выражения, предшествующего ключевому слову where
-}
```

## Вместе (бяка)
Рекомендация: не смешивайте let-in и where без особой надобности, такой код читается тяжело, избыточно.
```Haskell
module Main where

calcTime :: Int -> Int
calcTime timeIn =
  let delta = correction - 4
      threshold = 40
   in (if timeIn < threshold then timeIn + correction else timeIn + delta + correction)
  where
    -- правильно
    correction = timeIn * 2
    -- неправильно, ошибка компилирования Variable not in scope: threshold :: Int
    -- where не видит threshold, который выражен в let
    -- correction = timeIn * 2 * threshold

main :: IO ()
main = putStrLn "ok"
```

```Haskell
```

```Haskell
```


