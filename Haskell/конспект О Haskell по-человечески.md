# Приготовимся

Haskell — кроссплатформенный язык, работающий и в Linux, и в macOS OS X, и даже в Windows.


## Устанавливаем

[stack](https://docs.haskellstack.org/en/stable/install_and_upgrade/)

`stack` умеет
+ разворачивать инфраструктуру языка
+ собирать проекты
+ устанавливать библиотеки

глобальная инфраструктура последней стабильной версии в `~/.stack`.
    
    stack setup

новый проект с именем `real`.
    
    stack new real
    cd real
    ~/real$ tree
    .
    ├── ChangeLog.md
    ├── LICENSE
    ├── README.md
    ├── Setup.hs
    ├── app
    │   └── Main.hs         <- главный модуль программы
    ├── package.yaml
    ├── real.cabal          <- сборочный конфиг проекта
    ├── src
    │   └── Lib.hs          <- ещё один модуль
    ├── stack.yaml          <- конфиг stack
    ├── stack.yaml.lock
    └── test
        └── Spec.hs         <- тесты (пока не нужны)
    3 directories, 11 files

сборка

    stack clean && stack build --ghc-options="-Wall -Werror"

скомпилированный файл `real-exe` появится внутри `.stack-work/...`

    ~/real$ stack run
    someFunc


## Модули: знакомство

Проект состоит из модулей, файлов `*.hs` с исходным кодом. Один файл = один модуль. 

`src/Lib.hs`
```Haskell
module Lib      -- имя модуля
    ( someFunc  -- интерфейс модуля
    ) where

-- содержимое модуля - одна функция
someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

`app/Main.hs` - **главный модуль приложения, т.к. здесь определена функция** `main`.
```Haskell
module Main where

import Lib          -- подключаем модуль

main :: IO ()
main = someFunc     -- используем его содержимое
```

Модули либо наши, самописные, либо чужие в библиотеках. Существует стандартная библиотека.


## Для любопытных

+ Хотя `stack` появился в 2015, он является предпочтительным стартом в мир Haskell, даже в [Haskell Platform](https://www.haskell.org/platform/) он уже есть по умолчанию.

+ Имена файлов с исходным кодом принято начинать с большой буквы - для гармонии с именем модуля:
    ```shell
    app/Main.hs # module Main ...
    src/Lib.hs  # module Lib ...
    ```

+ новый проект может ~~быть проще по структуре, если использовать шаблон `stack new real_simple simple`~~ иметь другую структуру, подробнее о шаблонах `stack templates`.


# Киты и Черепаха

Основа всего (черепаха) = `ВЫРАЖЕНИЕ`, "три кита":
+ функция
+ тип
+ класс типов


## Черепаха

Haskell-программа является набором выражений.

> Выражение (англ. expression) — это то, что может дать нам некий полезный результат в результате вычисления (англ. evaluation) этого выражения.
> 
> Некоторые выражения уменьшаются (редуцируются - англ. reduce) в результате вычислений, а другие - нет.

```Haskell
1 + 2  -- при вычислении редуцируется в 3
```

Т.е. выражения вычисляются до тех пор, пока не останется окончательное, корневое выражение. Запуск Haskell-программы = запуск всей цепочки вычислений, где корень - `main` - главная точка программы.


## Первый кит = ФУНКЦИЯ

Функция делает выражение вычислимым, *отображает* входные данные на выходные. Это как машина: закинули на вход аргумент(ы), на выходе получили значение.

```Haskell
square v = v * v  -- определяем функцию

--Функция square определяет простую зависимость: числу 2 соответствует число 4, числу 3 — 9, и так далее. Схематично это можно записать так:

-- 2 -> 4
-- 3 -> 9
-- 4 -> 16
-- 5 -> 25
-- ...

square 2 -- применяем (англ. apply) функцию к аргументу
```

Вычисление выражения `1 + 2` это тоже применение функции
```Haskell
(+) 1 2  -- применение функции (+) к двум аргументам, 1 и 2
```

> Вызов функции (т.е. подпрограммы) происходит в C-подобных языках - каждая подпрограмма доступна по некоторому адресу в памяти - но не в Haskell!
>
> **Функция в Haskell это функция в математическом смысле**, её применяют к чему-то.


## Второй кит = ТИП

Аргументы (выражения) это данные (англ. data). Данные обязательно обладают
+ типом
+ значением (содержимым)

Работа с типами характеризуется важными чертами:

+ статическая проверка
    Проверка всех типов на этапе компиляции. Если функция работает с целыми, её не получится применить к строкам. Это гарантирует отсутствие целого пласта ошибок, не получится вычесть "метры" из "рублей".

+ сила
    пример проблемы слабой типизации в C:
    ```C
    double coeff(double base) {  // возвращает значение типа double
        return base * 4.9856;
    }

    int main() {
        int value = coeff(122.04);  // неявное приведение типов мы получим не 608.4426, а 608
        ...
    }
    ```
    Благодаря сильной типизации в Haskell это невозможно, код не пройдёт компиляцию, т.к. фактический тип выражения должен соответствовать ожидаемому

+ выведение
    ```Haskell
    value = 122.04 -- компилятор автоматически выведет тип double
    
    -- простейшие cтандартные типы
    1       Int
    1.0     Double
    'a'     Char
    "hello" String
    True    Bool
    False   Bool
    ```

## Третий Кит

позже))


## Для любопытных

В Haskell между "тип" и "класс типа" есть чёткое различие, не нужно пытаться строить аналогии с другими языками, чтобы не запутаться.


# Неизменность и чистота

Узнаем, что такое «чисто функциональный» язык и почему в нём нет места оператору присваивания.

## Объявление и Определение функции в коде

Нельзя работать с функцией, которая ничего не вычисляет, но можно с функцией, которая ничего не принимает.

```Haskell
-- ОБЪЯВЛЕНИЕ функции сообщает типы принимаемых аргументов и тип вычисляемого выражения
prod    :: Int      -> Int      -> Int {- Объявление функции
имя        тип         тип         тип
функции    первого     второго     вычисленного
           аргумента   аргумента   значения
-}

-- ОПРЕДЕЛЕНИЕ функции
prod     x          y         =    x * y {- Определение функции
имя      имя        имя       это  выражение
функции  первого    второго
         аргумента  аргумента

голова функции                равно    телу функции
-}
```

Голова равна телу - ~~операция присвоения~~ **декларация равенства левой и правой частей!**

"Отныне выражение `prod x y` равно выражению `x * y`". Можно безопасно заменить выражение `prod 2 3` на `2 * 3`, а `prod 20 30` на `20 * 30` и работа программы гарантированно не изменится. Потому, что


## Чисто функциональный

Haskell чисто функциональный язык (англ. purely functional), т.к. в центре - "чистая функция" (англ. pure function). Такая функция предельно честна с нами - её выходное значение целиком определяется только входными данными. Это функция в математическом смысле.

Функция `prod 20 30` чистая, без побочных эффектов (англ. side effects), она не способна сделать ничего, кроме как вычислить `600` 


## «Присваивание? Не, не слышал…»

Императивное программирование (англ. imperative programming) - несколько парадигм, в т.ч. ООП-парадигма, когде программа является набором инструкций, которые изменяют состояние программы, поэтому там есть переменные (англ. variable) которым "присваиваются" значения.

Декларативное программирование (англ. declarative programming) использует в т.ч. функциональную парадигму, когда программа является набором выражений, которые вычисляются применением функций к аргументам (другим выражениям) и не нужны переменные с операцией присваивания. Данные, созданные в программе единожды, уже не меняются.

**Знак `=` это равенство в математическом смысле**


## Для любопытных
В процессе работы Haskell-программы новые данные вычисляются на основе уже вычисленных, из-за этой особенности в памяти образуется множество уже не нужных данных. За своевременную уборку отвечает "сборщик мусора" (англ. garbage collector, GC), который встраивается в программу компилятором `GHC`.